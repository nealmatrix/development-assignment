# C++ Development Assignment

Research on the [Google FlatBuffers projects](https://google.github.io/flatbuffers/) and work on following tasks:

- Write a sample schema that can represent a property tree (property name, property value, property type, and sub-properties).
- Write code snippets in C++ that can read/update on the property object generated by the FlatBuffers compiler.
- Write code snippets in C++ that can send/receive the property object over TCP socket.
- Write code snippets in C++ that use the reflection API to read from the TCP socket and iterate over the elements stored inside the property tree.
- Consider the property tree will be updated frequently by the sender, think of a solution that synchronize the updates to the receiver.

---

### Task 1 - sample schema
- build flatc compiler tool
```bash
git clone https://github.com/google/flatbuffers.git
cd flatbuffers
mkdir build
cd build
cmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Release ..
make
```
- sample schema
    - property.fbs
    - defines property object
- compile the property schema
```bash
/Users/chuanyu/Dropbox/Code/Projects/open_sources/flatbuffers/build/flatc --gen-mutable --cpp property.fbs
```

---

### Task 2 - read/update property object
- read property object
    - `void read_property(uint8_t *buffer_pointer)` 
    - header in src/functions.h
    - source code in src/functions.cc
- update property object
    - `void update_property(uint8_t *buffer_pointer, float new_value)` 
    - header in src/functions.h
    - source code in src/functions.cc
- main program
    - src/read_update.cc
- compile and run
```bash
cd src
clang++ -Wall -std=c++11 -I"/Users/chuanyu/Dropbox/Code/Projects/open_sources/flatbuffers/include/" -c read_update.cc functions.cc
clang++ functions.o read_update.o -o read_update.out
./read_update.out
```
- output
```bash
buffer size: 68
property_name: my_proptery
property_value: 1.23
property_type: my_type
after change:
property_name: my_proptery
property_value: 10
property_type: my_type
```

---

### Task 3 - send/receive property over TCP socket
- send property over TCP socket
    - `void start_client()` 
    - header in src/functions.h
    - source code in src/functions.cc
- receive property over TCP socket
    - `void stop_server(int p)`, `void start_server()` 
    - header in src/functions.h
    - source code in src/functions.cc
- main program
    - src/client.cc
    - src/server.cc
- compile and run
```bash
cd src
clang++ -Wall -std=c++11 -I"/Users/chuanyu/Dropbox/Code/Projects/open_sources/flatbuffers/include/" -c server.cc client.cc functions.cc
clang++ functions.o client.o -o client.out
clang++ functions.o server.o -o server.out
./server.out
./client.out
```
- client output
```bash
buffer size: 68
```
- server output
```bash
property_name: my_proptery
property_value: 1.23
property_type: my_type
^Cclose server
```

---

### Task 4 - reflection api
- full reflection, use the following command to generate property.bfbs
```bash
cd src
/Users/chuanyu/Dropbox/Code/Projects/open_sources/flatbuffers/build/flatc -b --schema /Users/chuanyu/Dropbox/Code/Projects/open_sources/flatbuffers/reflection/reflection.fbs property.fbs 
```
- main program
    - src/reflection_api.cc
- compile and run
```bash
cd src
clang++ -Wall -std=c++11 -I"/Users/chuanyu/Dropbox/Code/Projects/open_sources/flatbuffers/include/" reflection_api.cc functions.cc /Users/chuanyu/Dropbox/Code/Projects/open_sources/flatbuffers/src/util.cpp -o reflection_api.out
./reflection_api.out
```
- After research, I can only use reflection api to get root table and list types in fbs.

---

### Task 5 - synchronize the updates
- Receiver can immediately receive the update made by the sender
    - Use publish-subscribe messaging. In a pub/sub model, any message published to a topic by sender is immediately received by the subscribers to the topic. 
    - In crypto exchange, it is usually to use websocket which utilizes publish-subscribe pattern. Websocket provides full-duplex communication channels over a single TCP connection. Users can get public and private data from exchanges passively.
- Once receiver received updates, how to efficiently update the property tree
    - Add unique id to each node. Then we can organize the property tree as binary search tree which can reduce the search time from O(n) to O(logn)
    - We can also use BFS(breadth-first search) or DFS(depth-first search) to find the node needs to be updated.